//-------------------------------------------------------------------------
// LaplacianFilter.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL Component LaplacianPipelined Definition
// Full name: LaplacianPipelined__x_size_100__y_size_100
// At c:\Users\Raul\Desktop\TFG\Laplacian\laplacianPipelined.py

module LaplacianFilter
(
  input  logic [0:0] clk ,
  input  logic [7:0] pixel_in ,
  output logic [7:0] pixel_out ,
  input  logic [0:0] reset ,
  output logic [0:0] valid_out 
);
  localparam logic [6:0] __const__x_size_at_up_line_buffers  = 7'd100;
  localparam logic [6:0] __const__x_size_at_up_counts  = 7'd100;
  localparam logic [6:0] __const__y_size_at_up_counts  = 7'd100;
  localparam logic [6:0] __const__x_size_at_pipeline_stage1_calc  = 7'd100;
  logic [6:0] col_count;
  logic [7:0] line_buffer1 [0:99];
  logic [7:0] line_buffer2 [0:99];
  logic [7:0] line_buffer3 [0:99];
  logic [6:0] reg_col_idx;
  logic [0:0] reg_is_valid;
  logic [11:0] reg_lap_sum;
  logic [6:0] reg_row_idx;
  logic [6:0] row_count;
  logic [6:0] s1_col_idx_w;
  logic [0:0] s1_is_valid_w;
  logic [11:0] s1_lap_sum_w;
  logic [6:0] s1_row_idx_w;
  logic [6:0] __tmpvar__up_line_buffers_current_row;
  logic [6:0] __tmpvar__up_line_buffers_current_col;
  logic [6:0] __tmpvar__up_counts_current_row;
  logic [6:0] __tmpvar__up_counts_current_col;
  logic [0:0] __tmpvar__pipeline_stage1_calc_is_valid_stage1;
  logic [6:0] __tmpvar__pipeline_stage1_calc_current_row;
  logic [6:0] __tmpvar__pipeline_stage1_calc_current_col;
  logic [7:0] __tmpvar__pipeline_stage1_calc_p_r_c_b;
  logic [7:0] __tmpvar__pipeline_stage1_calc_c_r_p_c_b;
  logic [7:0] __tmpvar__pipeline_stage1_calc_c_r_c_c_b;
  logic [7:0] __tmpvar__pipeline_stage1_calc_c_r_n_c_b;
  logic [7:0] __tmpvar__pipeline_stage1_calc_n_r_c_c_b;
  logic [11:0] __tmpvar__pipeline_stage1_calc_p_r_c_s12;
  logic [11:0] __tmpvar__pipeline_stage1_calc_c_r_p_c_s12;
  logic [11:0] __tmpvar__pipeline_stage1_calc_c_r_c_c_s12;
  logic [11:0] __tmpvar__pipeline_stage1_calc_c_r_n_c_s12;
  logic [11:0] __tmpvar__pipeline_stage1_calc_n_r_c_c_s12;
  logic [11:0] __tmpvar__pipeline_stage1_calc_lap_sum_s12;
  logic [11:0] __tmpvar__pipeline_stage2_clamp_output_registered_lap_sum;
  logic [0:0] __tmpvar__pipeline_stage2_clamp_output_is_neg;
  logic [3:0] __tmpvar__pipeline_stage2_clamp_output_upper_bits;
  logic [0:0] __tmpvar__pipeline_stage2_clamp_output_is_pos_overflow;
  logic [7:0] __tmpvar__pipeline_stage2_clamp_output_clamped_val_b8;

  // PyMTL Update Block Source
  // At c:\Users\Raul\Desktop\TFG\Laplacian\laplacianPipelined.py:80
  // @update
  // def pipeline_stage1_calc(): # Renombrado
  //     # Valores por defecto para wires intermedios
  //     s.s1_lap_sum_w  @= SInt12(0) # Default SInt12
  //     s.s1_is_valid_w @= b1(0)
  //     s.s1_row_idx_w  @= 0
  //     s.s1_col_idx_w  @= 0
  //     is_valid_stage1 = b1(0)
  // 
  //     current_row = s.row_count
  //     current_col = s.col_count
  // 
  //     if ( (current_row >= 2) &
  //          (current_col >= 1) &
  //          (current_col < x_size - 1) ):
  // 
  //         is_valid_stage1 = b1(1)
  // 
  //         # Leer Bits8
  //         p_r_c_b   = s.line_buffer1[current_col    ]
  //         c_r_p_c_b = s.line_buffer2[current_col - 1]
  //         c_r_c_c_b = s.line_buffer2[current_col    ]
  //         c_r_n_c_b = s.line_buffer2[current_col + 1]
  //         n_r_c_c_b = s.line_buffer3[current_col    ]
  // 
  //         # Extender a SInt12
  //         p_r_c_s12 = SInt12(zext(p_r_c_b, 12))
  //         c_r_p_c_s12 = SInt12(zext(c_r_p_c_b, 12))
  //         c_r_c_c_s12 = SInt12(zext(c_r_c_c_b, 12))
  //         c_r_n_c_s12 = SInt12(zext(c_r_n_c_b, 12))
  //         n_r_c_c_s12 = SInt12(zext(n_r_c_c_b, 12))
  // 
  //         # Calcular suma SInt12
  //         lap_sum_s12 = p_r_c_s12 + c_r_p_c_s12 - (c_r_c_c_s12 << 2) + c_r_n_c_s12 + n_r_c_c_s12
  // 
  //         # *** NO HAY CLAMPING AQUï¿½ ***
  // 
  //         # Asignar resultados a wires intermedios
  //         s.s1_lap_sum_w  @= lap_sum_s12 # Asignar la suma SInt12
  //         s.s1_is_valid_w @= is_valid_stage1
  //         s.s1_row_idx_w  @= current_row
  //         s.s1_col_idx_w  @= current_col
  
  always_comb begin : pipeline_stage1_calc
    s1_lap_sum_w = 12'd0;
    s1_is_valid_w = 1'd0;
    s1_row_idx_w = 7'd0;
    s1_col_idx_w = 7'd0;
    __tmpvar__pipeline_stage1_calc_is_valid_stage1 = 1'd0;
    __tmpvar__pipeline_stage1_calc_current_row = row_count;
    __tmpvar__pipeline_stage1_calc_current_col = col_count;
    if ( ( ( __tmpvar__pipeline_stage1_calc_current_row >= 7'd2 ) & ( __tmpvar__pipeline_stage1_calc_current_col >= 7'd1 ) ) & ( __tmpvar__pipeline_stage1_calc_current_col < ( 7'( __const__x_size_at_pipeline_stage1_calc ) - 7'd1 ) ) ) begin
      __tmpvar__pipeline_stage1_calc_is_valid_stage1 = 1'd1;
      __tmpvar__pipeline_stage1_calc_p_r_c_b = line_buffer1[__tmpvar__pipeline_stage1_calc_current_col];
      __tmpvar__pipeline_stage1_calc_c_r_p_c_b = line_buffer2[__tmpvar__pipeline_stage1_calc_current_col - 7'd1];
      __tmpvar__pipeline_stage1_calc_c_r_c_c_b = line_buffer2[__tmpvar__pipeline_stage1_calc_current_col];
      __tmpvar__pipeline_stage1_calc_c_r_n_c_b = line_buffer2[__tmpvar__pipeline_stage1_calc_current_col + 7'd1];
      __tmpvar__pipeline_stage1_calc_n_r_c_c_b = line_buffer3[__tmpvar__pipeline_stage1_calc_current_col];
      __tmpvar__pipeline_stage1_calc_p_r_c_s12 = 12'( { { 4 { 1'b0 } }, __tmpvar__pipeline_stage1_calc_p_r_c_b } );
      __tmpvar__pipeline_stage1_calc_c_r_p_c_s12 = 12'( { { 4 { 1'b0 } }, __tmpvar__pipeline_stage1_calc_c_r_p_c_b } );
      __tmpvar__pipeline_stage1_calc_c_r_c_c_s12 = 12'( { { 4 { 1'b0 } }, __tmpvar__pipeline_stage1_calc_c_r_c_c_b } );
      __tmpvar__pipeline_stage1_calc_c_r_n_c_s12 = 12'( { { 4 { 1'b0 } }, __tmpvar__pipeline_stage1_calc_c_r_n_c_b } );
      __tmpvar__pipeline_stage1_calc_n_r_c_c_s12 = 12'( { { 4 { 1'b0 } }, __tmpvar__pipeline_stage1_calc_n_r_c_c_b } );
      __tmpvar__pipeline_stage1_calc_lap_sum_s12 = ( ( ( __tmpvar__pipeline_stage1_calc_p_r_c_s12 + __tmpvar__pipeline_stage1_calc_c_r_p_c_s12 ) - ( __tmpvar__pipeline_stage1_calc_c_r_c_c_s12 << 2'd2 ) ) + __tmpvar__pipeline_stage1_calc_c_r_n_c_s12 ) + __tmpvar__pipeline_stage1_calc_n_r_c_c_s12;
      s1_lap_sum_w = __tmpvar__pipeline_stage1_calc_lap_sum_s12;
      s1_is_valid_w = __tmpvar__pipeline_stage1_calc_is_valid_stage1;
      s1_row_idx_w = __tmpvar__pipeline_stage1_calc_current_row;
      s1_col_idx_w = __tmpvar__pipeline_stage1_calc_current_col;
    end
  end

  // PyMTL Update Block Source
  // At c:\Users\Raul\Desktop\TFG\Laplacian\laplacianPipelined.py:140
  // @update
  // def pipeline_stage2_clamp_output():
  //     # Default outputs
  //     s.pixel_out @= Bits8(0)
  //     s.valid_out @= b1(0)
  // 
  //     if s.reg_is_valid: # Lee el wire s.reg_is_valid
  //         s.valid_out @= b1(1)
  // 
  //         registered_lap_sum = s.reg_lap_sum 
  // 
  //         is_neg = registered_lap_sum[11]
  //         upper_bits = registered_lap_sum[8:12]
  //         is_pos_overflow = ~is_neg & (upper_bits != 0)
  // 
  //         clamped_val_b8 = Bits8(0) 
  //         if is_neg == b1(1):
  //             clamped_val_b8 = Bits8(0)
  //         elif is_pos_overflow == b1(1):
  //             clamped_val_b8 = Bits8(255)
  //         else: 
  //             clamped_val_b8 = trunc(registered_lap_sum, 8)
  // 
  //         # Asignar valor clamped a la salida
  //         s.pixel_out @= clamped_val_b8
  // 
  //     # else: pixel_out y valid_out mantienen su valor por defecto 0
  
  always_comb begin : pipeline_stage2_clamp_output
    pixel_out = 8'd0;
    valid_out = 1'd0;
    if ( reg_is_valid ) begin
      valid_out = 1'd1;
      __tmpvar__pipeline_stage2_clamp_output_registered_lap_sum = reg_lap_sum;
      __tmpvar__pipeline_stage2_clamp_output_is_neg = __tmpvar__pipeline_stage2_clamp_output_registered_lap_sum[4'd11];
      __tmpvar__pipeline_stage2_clamp_output_upper_bits = __tmpvar__pipeline_stage2_clamp_output_registered_lap_sum[4'd11:4'd8];
      __tmpvar__pipeline_stage2_clamp_output_is_pos_overflow = ( ~__tmpvar__pipeline_stage2_clamp_output_is_neg ) & ( __tmpvar__pipeline_stage2_clamp_output_upper_bits != 4'd0 );
      __tmpvar__pipeline_stage2_clamp_output_clamped_val_b8 = 8'd0;
      if ( __tmpvar__pipeline_stage2_clamp_output_is_neg == 1'd1 ) begin
        __tmpvar__pipeline_stage2_clamp_output_clamped_val_b8 = 8'd0;
      end
      else if ( __tmpvar__pipeline_stage2_clamp_output_is_pos_overflow == 1'd1 ) begin
        __tmpvar__pipeline_stage2_clamp_output_clamped_val_b8 = 8'd255;
      end
      else
        __tmpvar__pipeline_stage2_clamp_output_clamped_val_b8 = 8'(__tmpvar__pipeline_stage2_clamp_output_registered_lap_sum);
      pixel_out = __tmpvar__pipeline_stage2_clamp_output_clamped_val_b8;
    end
  end

  // PyMTL Update Block Source
  // At c:\Users\Raul\Desktop\TFG\Laplacian\laplacianPipelined.py:62
  // @update_ff
  // def up_counts():
  //     if s.reset:
  //         s.row_count <<= 0
  //         s.col_count <<= 0
  //     else:
  //         current_row = s.row_count
  //         current_col = s.col_count
  //         if current_col == x_size - 1:
  //             s.col_count <<= 0
  //             if current_row == y_size - 1: s.row_count <<= 0
  //             else: s.row_count <<= current_row + 1
  //         else:
  //             s.col_count <<= current_col + 1
  //             s.row_count <<= current_row
  
  always_ff @(posedge clk) begin : up_counts
    if ( reset ) begin
      row_count <= 7'd0;
      col_count <= 7'd0;
    end
    else begin
      __tmpvar__up_counts_current_row = row_count;
      __tmpvar__up_counts_current_col = col_count;
      if ( __tmpvar__up_counts_current_col == ( 7'( __const__x_size_at_up_counts ) - 7'd1 ) ) begin
        col_count <= 7'd0;
        if ( __tmpvar__up_counts_current_row == ( 7'( __const__y_size_at_up_counts ) - 7'd1 ) ) begin
          row_count <= 7'd0;
        end
        else
          row_count <= __tmpvar__up_counts_current_row + 7'd1;
      end
      else begin
        col_count <= __tmpvar__up_counts_current_col + 7'd1;
        row_count <= __tmpvar__up_counts_current_row;
      end
    end
  end

  // PyMTL Update Block Source
  // At c:\Users\Raul\Desktop\TFG\Laplacian\laplacianPipelined.py:40
  // @update_ff
  // def up_line_buffers():
  //     if s.reset:
  //         for i in range(x_size):
  //             s.line_buffer1[i] <<= 0
  //             s.line_buffer2[i] <<= 0
  //             s.line_buffer3[i] <<= 0
  //     else:
  //         current_row = s.row_count
  //         current_col = s.col_count
  //         if current_row == 0: s.line_buffer1[current_col] <<= s.pixel_in
  //         elif current_row == 1: s.line_buffer2[current_col] <<= s.pixel_in
  //         elif current_row == 2: s.line_buffer3[current_col] <<= s.pixel_in
  //         else:
  //             if current_col == 0:
  //                 for i in range(x_size):
  //                     s.line_buffer1[i] <<= s.line_buffer2[i]
  //                     s.line_buffer2[i] <<= s.line_buffer3[i]
  //             # Escribir siempre en buffer 3 (la lï¿½gica concurrente aquï¿½ es sutil pero
  //             # PyMTL/Verilog deberï¿½an manejarla si la intenciï¿½n es clara)
  //             s.line_buffer3[current_col] <<= s.pixel_in
  
  always_ff @(posedge clk) begin : up_line_buffers
    if ( reset ) begin
      for ( int unsigned i = 1'd0; i < 7'( __const__x_size_at_up_line_buffers ); i += 1'd1 ) begin
        line_buffer1[7'(i)] <= 8'd0;
        line_buffer2[7'(i)] <= 8'd0;
        line_buffer3[7'(i)] <= 8'd0;
      end
    end
    else begin
      __tmpvar__up_line_buffers_current_row = row_count;
      __tmpvar__up_line_buffers_current_col = col_count;
      if ( __tmpvar__up_line_buffers_current_row == 7'd0 ) begin
        line_buffer1[__tmpvar__up_line_buffers_current_col] <= pixel_in;
      end
      else if ( __tmpvar__up_line_buffers_current_row == 7'd1 ) begin
        line_buffer2[__tmpvar__up_line_buffers_current_col] <= pixel_in;
      end
      else if ( __tmpvar__up_line_buffers_current_row == 7'd2 ) begin
        line_buffer3[__tmpvar__up_line_buffers_current_col] <= pixel_in;
      end
      else begin
        if ( __tmpvar__up_line_buffers_current_col == 7'd0 ) begin
          for ( int unsigned i = 1'd0; i < 7'( __const__x_size_at_up_line_buffers ); i += 1'd1 ) begin
            line_buffer1[7'(i)] <= line_buffer2[7'(i)];
            line_buffer2[7'(i)] <= line_buffer3[7'(i)];
          end
        end
        line_buffer3[__tmpvar__up_line_buffers_current_col] <= pixel_in;
      end
    end
  end

  // PyMTL Update Block Source
  // At c:\Users\Raul\Desktop\TFG\Laplacian\laplacianPipelined.py:125
  // @update_ff
  // def update_pipeline_regs():
  //     if s.reset:
  //         s.reg_lap_sum  <<= 0 # Reset wire SInt12
  //         s.reg_is_valid <<= 0
  //         s.reg_row_idx  <<= 0
  //         s.reg_col_idx  <<= 0
  //     else:
  //         s.reg_lap_sum  <<= s.s1_lap_sum_w # Captura SInt12
  //         s.reg_is_valid <<= s.s1_is_valid_w
  //         s.reg_row_idx  <<= s.s1_row_idx_w
  //         s.reg_col_idx  <<= s.s1_col_idx_w
  
  always_ff @(posedge clk) begin : update_pipeline_regs
    if ( reset ) begin
      reg_lap_sum <= 12'd0;
      reg_is_valid <= 1'd0;
      reg_row_idx <= 7'd0;
      reg_col_idx <= 7'd0;
    end
    else begin
      reg_lap_sum <= s1_lap_sum_w;
      reg_is_valid <= s1_is_valid_w;
      reg_row_idx <= s1_row_idx_w;
      reg_col_idx <= s1_col_idx_w;
    end
  end

endmodule
